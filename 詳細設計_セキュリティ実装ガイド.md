# セキュリティ実装ガイド

## 📋 目次
1. [認証システム](#認証システム)
2. [暗号化実装](#暗号化実装)
3. [セキュアコーディング](#セキュアコーディング)
4. [セキュリティヘッダー](#セキュリティヘッダー)
5. [監査・ログ](#監査ログ)

---

## 🔐 認証システム

### 1. パスワード管理

#### パスワードハッシュ化（Argon2id）

```php
<?php
// app/Services/Auth/PasswordService.php

class PasswordService
{
    /**
     * パスワードハッシュ生成（Argon2id推奨）
     */
    public function hash(string $password): string
    {
        // PHP 7.2+
        return password_hash($password, PASSWORD_ARGON2ID, [
            'memory_cost' => 65536,  // 64MB
            'time_cost' => 4,        // 4反復
            'threads' => 2           // 2スレッド
        ]);

        // PHP 7.2未満の場合はbcrypt
        // return password_hash($password, PASSWORD_BCRYPT, ['cost' => 12]);
    }

    /**
     * パスワード検証
     */
    public function verify(string $password, string $hash): bool
    {
        return password_verify($password, $hash);
    }

    /**
     * リハッシュが必要か確認
     */
    public function needsRehash(string $hash): bool
    {
        return password_needs_rehash($hash, PASSWORD_ARGON2ID, [
            'memory_cost' => 65536,
            'time_cost' => 4,
            'threads' => 2
        ]);
    }

    /**
     * パスワード強度検証
     */
    public function validateStrength(string $password): array
    {
        $errors = [];

        if (strlen($password) < 12) {
            $errors[] = 'パスワードは12文字以上必要です';
        }

        if (!preg_match('/[a-z]/', $password)) {
            $errors[] = '小文字を含める必要があります';
        }

        if (!preg_match('/[A-Z]/', $password)) {
            $errors[] = '大文字を含める必要があります';
        }

        if (!preg_match('/[0-9]/', $password)) {
            $errors[] = '数字を含める必要があります';
        }

        if (!preg_match('/[^a-zA-Z0-9]/', $password)) {
            $errors[] = '記号を含める必要があります';
        }

        // 一般的なパスワードチェック
        if ($this->isCommonPassword($password)) {
            $errors[] = 'よく使われるパスワードは使用できません';
        }

        return [
            'valid' => empty($errors),
            'errors' => $errors,
            'strength' => $this->calculateStrength($password)
        ];
    }

    /**
     * 一般的なパスワードチェック
     */
    private function isCommonPassword(string $password): bool
    {
        $commonPasswords = [
            'password', 'password123', '123456', 'qwerty',
            'admin', 'letmein', 'welcome', 'monkey'
        ];

        return in_array(strtolower($password), $commonPasswords);
    }

    /**
     * パスワード強度スコア計算
     */
    private function calculateStrength(string $password): int
    {
        $score = 0;

        $score += min(strlen($password) * 4, 40);
        $score += preg_match('/[a-z]/', $password) ? 10 : 0;
        $score += preg_match('/[A-Z]/', $password) ? 10 : 0;
        $score += preg_match('/[0-9]/', $password) ? 10 : 0;
        $score += preg_match('/[^a-zA-Z0-9]/', $password) ? 20 : 0;

        return min($score, 100);
    }
}
```

---

### 2. 二要素認証（2FA）

```php
<?php
// app/Services/Auth/TwoFactorService.php

use OTPHP\TOTP;
use BaconQrCode\Renderer\ImageRenderer;
use BaconQrCode\Renderer\Image\SvgImageBackEnd;
use BaconQrCode\Renderer\RendererStyle\RendererStyle;
use BaconQrCode\Writer;

class TwoFactorService
{
    /**
     * 2FA秘密鍵生成
     */
    public function generateSecret(string $email): array
    {
        $totp = TOTP::create();
        $totp->setLabel($email);
        $totp->setIssuer(config('app.name'));

        return [
            'secret' => $totp->getSecret(),
            'qr_code' => $this->generateQRCode($totp->getProvisioningUri()),
            'backup_codes' => $this->generateBackupCodes()
        ];
    }

    /**
     * QRコード生成
     */
    private function generateQRCode(string $uri): string
    {
        $renderer = new ImageRenderer(
            new RendererStyle(300),
            new SvgImageBackEnd()
        );

        $writer = new Writer($renderer);
        return $writer->writeString($uri);
    }

    /**
     * バックアップコード生成
     */
    private function generateBackupCodes(int $count = 8): array
    {
        $codes = [];

        for ($i = 0; $i < $count; $i++) {
            $codes[] = strtoupper(bin2hex(random_bytes(4)));
        }

        return $codes;
    }

    /**
     * TOTPコード検証
     */
    public function verify(string $secret, string $code): bool
    {
        $totp = TOTP::create($secret);

        // 前後30秒の誤差を許容
        return $totp->verify($code, null, 1);
    }

    /**
     * バックアップコード検証
     */
    public function verifyBackupCode(User $user, string $code): bool
    {
        $backupCodes = json_decode($user->two_factor_recovery_codes, true);

        if (in_array($code, $backupCodes)) {
            // 使用済みコードを削除
            $backupCodes = array_diff($backupCodes, [$code]);
            $user->two_factor_recovery_codes = json_encode(array_values($backupCodes));
            $user->save();

            return true;
        }

        return false;
    }
}
```

---

### 3. アカウントロックアウト

```php
<?php
// app/Services/Auth/LoginThrottleService.php

class LoginThrottleService
{
    private $redis;
    private $maxAttempts = 5;
    private $decayMinutes = 30;

    /**
     * ログイン試行回数をインクリメント
     */
    public function incrementAttempts(string $email): void
    {
        $key = $this->throttleKey($email);
        $attempts = (int) $this->redis->get($key);

        $this->redis->setex($key, $this->decayMinutes * 60, $attempts + 1);
    }

    /**
     * ロックアウト状態確認
     */
    public function isLockedOut(string $email): bool
    {
        return $this->attempts($email) >= $this->maxAttempts;
    }

    /**
     * 試行回数取得
     */
    public function attempts(string $email): int
    {
        return (int) $this->redis->get($this->throttleKey($email));
    }

    /**
     * ロックアウト解除までの残り時間（秒）
     */
    public function availableIn(string $email): int
    {
        return $this->redis->ttl($this->throttleKey($email));
    }

    /**
     * 試行回数リセット
     */
    public function clearAttempts(string $email): void
    {
        $this->redis->del($this->throttleKey($email));
    }

    /**
     * Redisキー生成
     */
    private function throttleKey(string $email): string
    {
        return 'login_throttle:' . hash('sha256', $email);
    }

    /**
     * IPベースのレート制限
     */
    public function checkIPRateLimit(string $ip): bool
    {
        $key = 'ip_login_throttle:' . $ip;
        $attempts = (int) $this->redis->get($key);

        if ($attempts >= 20) { // IP単位で1時間に20回まで
            return false;
        }

        $this->redis->setex($key, 3600, $attempts + 1);
        return true;
    }
}
```

---

## 🔒 暗号化実装

### 1. データベース暗号化

```php
<?php
// app/Services/Encryption/FieldEncryption.php

use Illuminate\Support\Facades\Crypt;

class FieldEncryption
{
    /**
     * フィールド暗号化（AES-256-GCM）
     */
    public function encrypt($value): string
    {
        if (is_null($value)) {
            return null;
        }

        return Crypt::encrypt($value);
    }

    /**
     * フィールド復号化
     */
    public function decrypt($value)
    {
        if (is_null($value)) {
            return null;
        }

        try {
            return Crypt::decrypt($value);
        } catch (DecryptException $e) {
            // 復号化失敗時の処理
            Log::error('Decryption failed', ['error' => $e->getMessage()]);
            return null;
        }
    }
}

// Eloquent モデルでの使用
class User extends Model
{
    /**
     * 自動暗号化するカラム
     */
    protected $encrypted = [
        'ssn',              // 社会保障番号
        'bank_account',     // 銀行口座
        'tax_id',           // 納税者番号
    ];

    /**
     * アクセサ（取得時に復号化）
     */
    public function getSsnAttribute($value)
    {
        return app(FieldEncryption::class)->decrypt($value);
    }

    /**
     * ミューテータ（保存時に暗号化）
     */
    public function setSsnAttribute($value)
    {
        $this->attributes['ssn'] = app(FieldEncryption::class)->encrypt($value);
    }
}
```

---

### 2. トークン生成（セキュアランダム）

```php
<?php
// app/Services/Token/TokenGenerator.php

class TokenGenerator
{
    /**
     * セキュアなランダムトークン生成
     */
    public function generate(int $length = 32): string
    {
        return bin2hex(random_bytes($length));
    }

    /**
     * API キー生成（プレフィックス付き）
     */
    public function generateApiKey(string $prefix = 'sk_live'): string
    {
        $randomPart = $this->generate(32);
        return "{$prefix}_{$randomPart}";
    }

    /**
     * パスワードリセットトークン生成
     */
    public function generatePasswordResetToken(User $user): string
    {
        $token = $this->generate(32);

        DB::table('password_resets')->insert([
            'email' => $user->email,
            'token' => hash('sha256', $token), // ハッシュ化して保存
            'created_at' => now()
        ]);

        return $token; // 平文をメール送信
    }

    /**
     * CSRF トークン生成
     */
    public function generateCsrfToken(): string
    {
        if (empty($_SESSION['csrf_token'])) {
            $_SESSION['csrf_token'] = $this->generate(32);
        }

        return $_SESSION['csrf_token'];
    }

    /**
     * CSRF トークン検証
     */
    public function verifyCsrfToken(string $token): bool
    {
        if (empty($_SESSION['csrf_token'])) {
            return false;
        }

        return hash_equals($_SESSION['csrf_token'], $token);
    }
}
```

---

## 🛡 セキュアコーディング

### 1. SQL インジェクション対策

```php
<?php
// ❌ 危険（脆弱）
$userId = $_GET['id'];
$query = "SELECT * FROM users WHERE id = " . $userId;
$result = mysqli_query($conn, $query);

// ✅ 安全（プリペアドステートメント）
$userId = $_GET['id'];
$stmt = $pdo->prepare('SELECT * FROM users WHERE id = :id');
$stmt->execute(['id' => $userId]);
$result = $stmt->fetch();

// ✅ Laravel（Eloquent ORM）
$user = User::find($userId);

// ✅ クエリビルダー
$users = DB::table('users')
    ->where('status', '=', $status)
    ->orderBy('created_at', 'desc')
    ->get();
```

---

### 2. XSS 対策

```php
<?php
// ❌ 危険
echo $_GET['name'];
echo "<div>" . $userInput . "</div>";

// ✅ 安全（エスケープ）
echo htmlspecialchars($_GET['name'], ENT_QUOTES, 'UTF-8');

// ✅ Laravel Blade（自動エスケープ）
{{ $userInput }}  // 自動エスケープ
{!! $trustedHtml !!}  // 手動エスケープ（信頼できるHTMLのみ）

// JavaScript内でのエスケープ
<script>
var userName = <?= json_encode($userName, JSON_HEX_TAG | JSON_HEX_AMP) ?>;
</script>
```

---

### 3. CSRF 対策

```php
<?php
// フォームにCSRFトークン埋め込み
<form method="POST" action="/api/campaigns">
    <input type="hidden" name="_token" value="<?= csrf_token() ?>">
    <!-- フォームフィールド -->
</form>

// ミドルウェアで検証
class VerifyCsrfToken
{
    public function handle($request, Closure $next)
    {
        if ($this->isReading($request) || $this->tokensMatch($request)) {
            return $next($request);
        }

        throw new TokenMismatchException('CSRF token mismatch');
    }

    protected function tokensMatch($request)
    {
        $token = $request->input('_token') ?: $request->header('X-CSRF-TOKEN');

        return hash_equals(
            $request->session()->token(),
            $token
        );
    }
}
```

---

### 4. ファイルアップロードセキュリティ

```php
<?php
// app/Services/Upload/SecureFileUpload.php

class SecureFileUpload
{
    private $allowedMimes = [
        'image/jpeg',
        'image/png',
        'image/gif',
        'image/webp',
        'application/pdf'
    ];

    private $maxFileSize = 5 * 1024 * 1024; // 5MB

    /**
     * セキュアなファイルアップロード
     */
    public function upload(UploadedFile $file): array
    {
        // 1. ファイルサイズチェック
        if ($file->getSize() > $this->maxFileSize) {
            throw new ValidationException('ファイルサイズが大きすぎます');
        }

        // 2. MIME タイプ検証
        $finfo = finfo_open(FILEINFO_MIME_TYPE);
        $mimeType = finfo_file($finfo, $file->getPathname());
        finfo_close($finfo);

        if (!in_array($mimeType, $this->allowedMimes)) {
            throw new ValidationException('許可されていないファイル形式です');
        }

        // 3. 拡張子検証
        $extension = $file->getClientOriginalExtension();
        if (!$this->isAllowedExtension($extension, $mimeType)) {
            throw new ValidationException('拡張子とMIMEタイプが一致しません');
        }

        // 4. ファイル名のサニタイズ
        $originalName = $this->sanitizeFilename($file->getClientOriginalName());

        // 5. ランダムなファイル名生成
        $filename = bin2hex(random_bytes(16)) . '.' . $extension;

        // 6. ウイルススキャン（ClamAV等）
        if ($this->hasVirus($file->getPathname())) {
            throw new SecurityException('ウイルスが検出されました');
        }

        // 7. ファイル保存（公開ディレクトリ外）
        $path = storage_path('app/uploads/' . date('Y/m/d'));

        if (!file_exists($path)) {
            mkdir($path, 0755, true);
        }

        $file->move($path, $filename);

        // 8. パーミッション設定
        chmod($path . '/' . $filename, 0644);

        return [
            'filename' => $filename,
            'original_name' => $originalName,
            'path' => $path . '/' . $filename,
            'mime_type' => $mimeType,
            'size' => $file->getSize()
        ];
    }

    /**
     * ファイル名サニタイズ
     */
    private function sanitizeFilename(string $filename): string
    {
        // 危険な文字を除去
        $filename = preg_replace('/[^a-zA-Z0-9._-]/', '_', $filename);

        // パストラバーサル防止
        $filename = str_replace(['..', '/', '\\'], '', $filename);

        return substr($filename, 0, 255);
    }

    /**
     * ウイルススキャン
     */
    private function hasVirus(string $filepath): bool
    {
        // ClamAV使用例
        $clamscan = '/usr/bin/clamscan';

        if (file_exists($clamscan)) {
            exec("$clamscan --no-summary $filepath", $output, $returnCode);
            return $returnCode !== 0;
        }

        return false;
    }
}
```

---

## 🌐 セキュリティヘッダー

### 1. 推奨セキュリティヘッダー設定

```php
<?php
// app/Http/Middleware/SecurityHeaders.php

class SecurityHeaders
{
    public function handle($request, Closure $next)
    {
        $response = $next($request);

        // Content Security Policy
        $response->headers->set('Content-Security-Policy',
            "default-src 'self'; " .
            "script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.example.com; " .
            "style-src 'self' 'unsafe-inline' https://cdn.example.com; " .
            "img-src 'self' data: https:; " .
            "font-src 'self' data: https://cdn.example.com; " .
            "connect-src 'self' https://api.example.com; " .
            "frame-ancestors 'none'; " .
            "base-uri 'self'; " .
            "form-action 'self'"
        );

        // X-Frame-Options（クリックジャッキング対策）
        $response->headers->set('X-Frame-Options', 'DENY');

        // X-Content-Type-Options（MIMEスニッフィング防止）
        $response->headers->set('X-Content-Type-Options', 'nosniff');

        // X-XSS-Protection
        $response->headers->set('X-XSS-Protection', '1; mode=block');

        // Strict-Transport-Security（HSTS）
        $response->headers->set('Strict-Transport-Security',
            'max-age=31536000; includeSubDomains; preload'
        );

        // Referrer-Policy
        $response->headers->set('Referrer-Policy', 'strict-origin-when-cross-origin');

        // Permissions-Policy（旧 Feature-Policy）
        $response->headers->set('Permissions-Policy',
            'geolocation=(), microphone=(), camera=()'
        );

        return $response;
    }
}
```

---

## 📝 監査・ログ

### 1. セキュリティログ記録

```php
<?php
// app/Services/Audit/AuditLogger.php

class AuditLogger
{
    /**
     * セキュリティイベント記録
     */
    public function logSecurityEvent(string $event, array $data = []): void
    {
        Log::channel('security')->info($event, array_merge($data, [
            'user_id' => auth()->id(),
            'ip' => request()->ip(),
            'user_agent' => request()->userAgent(),
            'timestamp' => now()->toIso8601String(),
            'request_id' => request()->header('X-Request-ID')
        ]));
    }

    /**
     * ログイン成功ログ
     */
    public function logLoginSuccess(User $user): void
    {
        $this->logSecurityEvent('LOGIN_SUCCESS', [
            'user_id' => $user->id,
            'email' => $user->email,
            'two_factor_used' => $user->two_factor_enabled
        ]);
    }

    /**
     * ログイン失敗ログ
     */
    public function logLoginFailed(string $email, string $reason): void
    {
        $this->logSecurityEvent('LOGIN_FAILED', [
            'email' => $email,
            'reason' => $reason,
            'attempts' => $this->getFailedAttempts($email)
        ]);
    }

    /**
     * パスワード変更ログ
     */
    public function logPasswordChanged(User $user): void
    {
        $this->logSecurityEvent('PASSWORD_CHANGED', [
            'user_id' => $user->id
        ]);

        // セキュリティ通知メール送信
        Mail::to($user)->send(new PasswordChangedNotification());
    }

    /**
     * 不正アクセス試行ログ
     */
    public function logUnauthorizedAccess(string $resource, string $action): void
    {
        $this->logSecurityEvent('UNAUTHORIZED_ACCESS', [
            'resource' => $resource,
            'action' => $action,
            'severity' => 'HIGH'
        ]);

        // 重要度が高い場合は即座に通知
        $this->sendSecurityAlert('不正アクセス試行が検出されました');
    }

    /**
     * データ変更監査ログ
     */
    public function logDataChange(string $model, $id, array $changes): void
    {
        DB::table('audit_logs')->insert([
            'user_id' => auth()->id(),
            'action' => 'UPDATE',
            'entity_type' => $model,
            'entity_id' => $id,
            'old_values' => json_encode($changes['old']),
            'new_values' => json_encode($changes['new']),
            'ip_address' => request()->ip(),
            'user_agent' => request()->userAgent(),
            'created_at' => now()
        ]);
    }
}

// Eloquent モデルでの自動監査ログ
class Campaign extends Model
{
    use Auditable;

    protected static function boot()
    {
        parent::boot();

        static::updated(function ($model) {
            app(AuditLogger::class)->logDataChange(
                'Campaign',
                $model->id,
                [
                    'old' => $model->getOriginal(),
                    'new' => $model->getAttributes()
                ]
            );
        });
    }
}
```

---

### 2. リアルタイム脅威検知

```php
<?php
// app/Services/Security/ThreatDetector.php

class ThreatDetector
{
    /**
     * 異常なアクセスパターン検知
     */
    public function detectAnomalousActivity(User $user): bool
    {
        // 1. 地理的異常（通常と異なる場所からのアクセス）
        if ($this->detectGeoAnomaly($user)) {
            $this->sendSecurityAlert($user, 'GEO_ANOMALY');
            return true;
        }

        // 2. デバイス変更検知
        if ($this->detectNewDevice($user)) {
            $this->requireAdditionalVerification($user);
        }

        // 3. 短時間での大量リクエスト
        if ($this->detectRapidRequests($user)) {
            $this->temporaryRateLimit($user);
            return true;
        }

        // 4. 異常な操作パターン
        if ($this->detectUnusualBehavior($user)) {
            $this->flagForManualReview($user);
        }

        return false;
    }

    /**
     * 地理的異常検知
     */
    private function detectGeoAnomaly(User $user): bool
    {
        $currentLocation = $this->getIPLocation(request()->ip());
        $lastLocation = $this->getLastLoginLocation($user);

        if (!$lastLocation) {
            return false;
        }

        // 前回ログインから1時間以内に1000km以上移動
        $distance = $this->calculateDistance($currentLocation, $lastLocation);
        $timeDiff = now()->diffInHours($user->last_login_at);

        if ($distance > 1000 && $timeDiff < 1) {
            return true;
        }

        return false;
    }
}
```

---

これらのセキュリティ実装により、現代的なセキュリティ基準を満たすシステムを構築できます。
