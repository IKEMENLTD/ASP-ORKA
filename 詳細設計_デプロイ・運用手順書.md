# デプロイ・運用手順書

## 📋 目次
1. [インフラ構成](#インフラ構成)
2. [デプロイ手順](#デプロイ手順)
3. [CI/CDパイプライン](#cicdパイプライン)
4. [監視・アラート](#監視アラート)
5. [バックアップ・復旧](#バックアップ復旧)
6. [障害対応](#障害対応)

---

## 🏗 インフラ構成

### 推奨インフラアーキテクチャ（AWS）

```
┌─────────────────────────────────────────────────────────────────┐
│                        CloudFront (CDN)                          │
│                    + AWS WAF (Web Application Firewall)          │
└─────────────────────────────────────────────────────────────────┘
                                ↓
┌─────────────────────────────────────────────────────────────────┐
│                    Route 53 (DNS)                                │
└─────────────────────────────────────────────────────────────────┘
                                ↓
┌─────────────────────────────────────────────────────────────────┐
│              Application Load Balancer (ALB)                     │
│              + SSL/TLS Termination (ACM)                        │
└─────────────────────────────────────────────────────────────────┘
                                ↓
        ┌───────────────────┬───────────────────┐
        ↓                   ↓                   ↓
┌───────────────┐   ┌───────────────┐   ┌───────────────┐
│  ECS Fargate  │   │  ECS Fargate  │   │  ECS Fargate  │
│  (Web Tier)   │   │  (Web Tier)   │   │  (Web Tier)   │
│  Auto Scaling │   │  Auto Scaling │   │  Auto Scaling │
└───────────────┘   └───────────────┘   └───────────────┘
        │                   │                   │
        └───────────────────┴───────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────────┐
│                    ElastiCache (Redis)                           │
│              - Session Store                                     │
│              - Application Cache                                 │
│              - Queue Backend                                     │
└─────────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────────┐
│                    RDS Aurora (MySQL)                            │
│              - Multi-AZ                                          │
│              - Read Replica (3台)                               │
│              - Auto Scaling                                      │
└─────────────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────────────┐
│                         S3                                       │
│              - Static Assets                                     │
│              - File Uploads                                      │
│              - Backups                                           │
└─────────────────────────────────────────────────────────────────┘
```

---

### インフラ as Code（Terraform）

```hcl
# terraform/main.tf

terraform {
  required_version = ">= 1.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }

  backend "s3" {
    bucket = "affiliate-system-terraform-state"
    key    = "production/terraform.tfstate"
    region = "ap-northeast-1"
    encrypt = true
  }
}

provider "aws" {
  region = var.aws_region
}

# VPC
module "vpc" {
  source = "terraform-aws-modules/vpc/aws"

  name = "affiliate-system-vpc"
  cidr = "10.0.0.0/16"

  azs             = ["ap-northeast-1a", "ap-northeast-1c", "ap-northeast-1d"]
  private_subnets = ["10.0.1.0/24", "10.0.2.0/24", "10.0.3.0/24"]
  public_subnets  = ["10.0.101.0/24", "10.0.102.0/24", "10.0.103.0/24"]

  enable_nat_gateway = true
  enable_vpn_gateway = false
  enable_dns_hostnames = true
}

# RDS Aurora
module "aurora" {
  source = "terraform-aws-modules/rds-aurora/aws"

  name           = "affiliate-system-aurora"
  engine         = "aurora-mysql"
  engine_version = "8.0.mysql_aurora.3.04.0"
  instance_class = "db.r6g.xlarge"

  instances = {
    writer = {
      instance_class = "db.r6g.2xlarge"
    }
    reader1 = {
      instance_class = "db.r6g.xlarge"
    }
    reader2 = {
      instance_class = "db.r6g.xlarge"
    }
  }

  vpc_id                 = module.vpc.vpc_id
  db_subnet_group_name   = module.vpc.database_subnet_group_name
  create_security_group  = true

  apply_immediately   = false
  skip_final_snapshot = false

  enabled_cloudwatch_logs_exports = ["audit", "error", "slowquery"]

  backup_retention_period = 30
  preferred_backup_window = "03:00-04:00"

  auto_minor_version_upgrade = true

  performance_insights_enabled = true

  tags = {
    Environment = "production"
    Project     = "affiliate-system"
  }
}

# ElastiCache Redis
module "redis" {
  source = "terraform-aws-modules/elasticache/aws"

  cluster_id           = "affiliate-redis"
  engine               = "redis"
  engine_version       = "7.0"
  node_type            = "cache.r6g.xlarge"
  num_cache_nodes      = 3
  parameter_group_name = "default.redis7.cluster.on"

  port = 6379

  subnet_group_name = module.vpc.elasticache_subnet_group_name
  security_group_ids = [aws_security_group.redis.id]

  automatic_failover_enabled = true
  multi_az_enabled          = true

  at_rest_encryption_enabled = true
  transit_encryption_enabled = true

  snapshot_retention_limit = 5
  snapshot_window         = "03:00-05:00"

  tags = {
    Environment = "production"
  }
}

# ECS Cluster
resource "aws_ecs_cluster" "main" {
  name = "affiliate-system-cluster"

  setting {
    name  = "containerInsights"
    value = "enabled"
  }
}

# ECS Service
resource "aws_ecs_service" "web" {
  name            = "affiliate-web"
  cluster         = aws_ecs_cluster.main.id
  task_definition = aws_ecs_task_definition.web.arn
  desired_count   = 3
  launch_type     = "FARGATE"

  network_configuration {
    subnets         = module.vpc.private_subnets
    security_groups = [aws_security_group.ecs_tasks.id]
  }

  load_balancer {
    target_group_arn = aws_lb_target_group.web.arn
    container_name   = "app"
    container_port   = 80
  }

  autoscaling {
    min_capacity = 3
    max_capacity = 20

    target_tracking_scaling_policy {
      predefined_metric_type = "ECSServiceAverageCPUUtilization"
      target_value           = 70.0
    }
  }
}
```

---

## 🚀 デプロイ手順

### 1. Docker イメージビルド

```dockerfile
# Dockerfile (マルチステージビルド)

# ステージ1: ビルド環境
FROM php:8.3-fpm-alpine AS builder

WORKDIR /app

# PHP拡張インストール
RUN apk add --no-cache \
    postgresql-dev \
    libzip-dev \
    && docker-php-ext-install pdo pdo_mysql zip opcache

# Composer インストール
COPY --from=composer:2 /usr/bin/composer /usr/bin/composer

# 依存関係インストール
COPY composer.json composer.lock ./
RUN composer install --no-dev --optimize-autoloader --no-interaction

# アプリケーションコードコピー
COPY . .

# ステージ2: 本番環境
FROM php:8.3-fpm-alpine

WORKDIR /var/www/html

# 必要な拡張のみインストール
RUN apk add --no-cache postgresql-libs libzip

# ビルド成果物コピー
COPY --from=builder /app /var/www/html
COPY --from=builder /usr/local/lib/php/extensions /usr/local/lib/php/extensions

# 権限設定
RUN chown -R www-data:www-data /var/www/html/storage /var/www/html/bootstrap/cache

# ヘルスチェック
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD php artisan health:check || exit 1

EXPOSE 9000

CMD ["php-fpm"]
```

```bash
#!/bin/bash
# build-and-push.sh

set -e

VERSION=$(git describe --tags --always)
REGION="ap-northeast-1"
ACCOUNT_ID="123456789012"
ECR_REPO="${ACCOUNT_ID}.dkr.ecr.${REGION}.amazonaws.com/affiliate-system"

echo "Building Docker image version: $VERSION"

# ビルド
docker build -t affiliate-system:${VERSION} .
docker tag affiliate-system:${VERSION} ${ECR_REPO}:${VERSION}
docker tag affiliate-system:${VERSION} ${ECR_REPO}:latest

# ECR ログイン
aws ecr get-login-password --region ${REGION} | \
  docker login --username AWS --password-stdin ${ECR_REPO}

# プッシュ
docker push ${ECR_REPO}:${VERSION}
docker push ${ECR_REPO}:latest

echo "Image pushed: ${ECR_REPO}:${VERSION}"
```

---

### 2. データベースマイグレーション

```bash
#!/bin/bash
# deploy/migrate.sh

set -e

echo "Running database migrations..."

# マイグレーション前バックアップ
aws rds create-db-snapshot \
  --db-instance-identifier affiliate-db-prod \
  --db-snapshot-identifier pre-migration-$(date +%Y%m%d-%H%M%S)

# マイグレーション実行
php artisan migrate --force

# 失敗時のロールバック
if [ $? -ne 0 ]; then
  echo "Migration failed! Rolling back..."
  php artisan migrate:rollback --force
  exit 1
fi

echo "Migration completed successfully"
```

---

### 3. ブルーグリーンデプロイメント

```bash
#!/bin/bash
# deploy/blue-green-deploy.sh

set -e

CLUSTER="affiliate-system-cluster"
SERVICE="affiliate-web"
NEW_TASK_DEF="affiliate-web:${VERSION}"

echo "Starting Blue-Green Deployment..."

# 1. 新バージョンのタスク定義登録
aws ecs register-task-definition --cli-input-json file://task-definition.json

# 2. 現在のタスク数取得
CURRENT_DESIRED=$(aws ecs describe-services \
  --cluster ${CLUSTER} \
  --services ${SERVICE} \
  --query 'services[0].desiredCount' \
  --output text)

# 3. 新バージョンを段階的にデプロイ
echo "Deploying new version..."
aws ecs update-service \
  --cluster ${CLUSTER} \
  --service ${SERVICE} \
  --task-definition ${NEW_TASK_DEF} \
  --desired-count ${CURRENT_DESIRED}

# 4. デプロイ完了待機
aws ecs wait services-stable \
  --cluster ${CLUSTER} \
  --services ${SERVICE}

# 5. ヘルスチェック
echo "Running health checks..."
HEALTH_CHECK_URL="https://api.affiliate-system.com/health"

for i in {1..10}; do
  HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" ${HEALTH_CHECK_URL})

  if [ "$HTTP_CODE" -eq 200 ]; then
    echo "Health check passed!"
    break
  fi

  if [ $i -eq 10 ]; then
    echo "Health check failed after 10 attempts"
    # ロールバック
    ./rollback.sh
    exit 1
  fi

  echo "Health check attempt $i failed, retrying..."
  sleep 10
done

echo "Blue-Green Deployment completed successfully!"
```

---

## 🔄 CI/CDパイプライン

### GitHub Actions ワークフロー

```yaml
# .github/workflows/deploy.yml

name: Deploy to Production

on:
  push:
    branches:
      - main
    tags:
      - 'v*'

env:
  AWS_REGION: ap-northeast-1
  ECR_REPOSITORY: affiliate-system
  ECS_CLUSTER: affiliate-system-cluster
  ECS_SERVICE: affiliate-web

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.3'
          extensions: mbstring, pdo, pdo_mysql

      - name: Install dependencies
        run: composer install --prefer-dist --no-progress

      - name: Run tests
        run: |
          php artisan test --parallel
          php artisan test:coverage

      - name: Security scan
        run: |
          composer audit
          ./vendor/bin/psalm --show-info=true

  build-and-deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
      - uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Database Migration
        run: |
          aws ecs run-task \
            --cluster ${{ env.ECS_CLUSTER }} \
            --task-definition affiliate-migration \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[subnet-xxx],securityGroups=[sg-xxx]}"

      - name: Deploy to ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: task-definition.json
          service: ${{ env.ECS_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true

      - name: Notify Slack
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: 'Deployment to production'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
```

---

## 📊 監視・アラート

### CloudWatch ダッシュボード

```json
{
  "widgets": [
    {
      "type": "metric",
      "properties": {
        "metrics": [
          ["AWS/ECS", "CPUUtilization", { "stat": "Average" }],
          [".", "MemoryUtilization", { "stat": "Average" }]
        ],
        "period": 300,
        "stat": "Average",
        "region": "ap-northeast-1",
        "title": "ECS Resource Utilization"
      }
    },
    {
      "type": "metric",
      "properties": {
        "metrics": [
          ["AWS/RDS", "DatabaseConnections", { "stat": "Sum" }],
          [".", "CPUUtilization", { "stat": "Average" }],
          [".", "FreeableMemory", { "stat": "Average" }]
        ],
        "period": 300,
        "stat": "Average",
        "region": "ap-northeast-1",
        "title": "RDS Performance"
      }
    },
    {
      "type": "log",
      "properties": {
        "query": "SOURCE '/aws/ecs/affiliate-system'\n| filter @message like /ERROR/\n| stats count() by bin(5m)",
        "region": "ap-northeast-1",
        "title": "Error Logs"
      }
    }
  ]
}
```

---

### Datadog 監視設定

```yaml
# datadog/monitors.yaml

- name: "High Error Rate"
  type: metric alert
  query: "avg(last_5m):sum:api.errors{env:production} > 100"
  message: |
    エラー率が異常に高くなっています
    @slack-oncall @pagerduty
  tags:
    - "env:production"
    - "severity:critical"

- name: "API Response Time"
  type: metric alert
  query: "avg(last_10m):avg:api.response_time{env:production} > 1000"
  message: |
    APIレスポンスタイムが1秒を超えています
    @slack-engineering
  tags:
    - "env:production"
    - "severity:warning"

- name: "Database Connection Pool"
  type: metric alert
  query: "avg(last_5m):avg:mysql.performance.threads_connected{*} / avg:mysql.performance.max_connections{*} > 0.8"
  message: |
    データベース接続プールが80%を超えています
    @slack-oncall
```

---

## 💾 バックアップ・復旧

### 自動バックアップ設定

```bash
#!/bin/bash
# backup/automated-backup.sh

DATE=$(date +%Y%m%d_%H%M%S)
S3_BUCKET="s3://affiliate-system-backups"

# 1. データベースバックアップ
echo "Starting database backup..."

mysqldump \
  --host=aurora-cluster.xxx.ap-northeast-1.rds.amazonaws.com \
  --user=admin \
  --password=$DB_PASSWORD \
  --single-transaction \
  --quick \
  --lock-tables=false \
  --routines \
  --triggers \
  --events \
  affiliate_production | gzip > /tmp/db_backup_${DATE}.sql.gz

# S3にアップロード
aws s3 cp /tmp/db_backup_${DATE}.sql.gz ${S3_BUCKET}/database/

# 2. ファイルバックアップ
echo "Starting file backup..."

aws s3 sync /var/www/html/storage/app/uploads ${S3_BUCKET}/files/${DATE}/

# 3. Redis スナップショット
echo "Creating Redis snapshot..."

aws elasticache create-snapshot \
  --replication-group-id affiliate-redis \
  --snapshot-name redis-backup-${DATE}

# 4. 古いバックアップ削除（30日以前）
echo "Cleaning up old backups..."

aws s3 ls ${S3_BUCKET}/database/ | \
  awk '{print $4}' | \
  while read file; do
    file_date=$(echo $file | grep -oP '\d{8}')
    if [ $(date -d "${file_date}" +%s) -lt $(date -d '30 days ago' +%s) ]; then
      aws s3 rm ${S3_BUCKET}/database/$file
    fi
  done

echo "Backup completed: ${DATE}"
```

---

### 災害復旧手順

```bash
#!/bin/bash
# recovery/disaster-recovery.sh

BACKUP_DATE="20240115_120000"
S3_BUCKET="s3://affiliate-system-backups"

echo "Starting disaster recovery from backup: ${BACKUP_DATE}"

# 1. データベース復元
echo "Restoring database..."

aws s3 cp ${S3_BUCKET}/database/db_backup_${BACKUP_DATE}.sql.gz /tmp/
gunzip /tmp/db_backup_${BACKUP_DATE}.sql.gz

mysql \
  --host=aurora-cluster.xxx.ap-northeast-1.rds.amazonaws.com \
  --user=admin \
  --password=$DB_PASSWORD \
  affiliate_production < /tmp/db_backup_${BACKUP_DATE}.sql

# 2. ファイル復元
echo "Restoring files..."

aws s3 sync ${S3_BUCKET}/files/${BACKUP_DATE}/ /var/www/html/storage/app/uploads/

# 3. キャッシュクリア
echo "Clearing cache..."

php artisan cache:clear
php artisan config:clear
php artisan route:clear
php artisan view:clear

# 4. サービス再起動
echo "Restarting services..."

aws ecs update-service \
  --cluster affiliate-system-cluster \
  --service affiliate-web \
  --force-new-deployment

echo "Disaster recovery completed!"
```

---

## 🚨 障害対応

### インシデント対応フロー

```
1. 検知（5分以内）
   └→ CloudWatch / Datadog アラート
   └→ PagerDuty 自動通知
   └→ Slack #incidents チャンネル

2. 初動対応（15分以内）
   └→ オンコール担当者確認
   └→ 影響範囲調査
   └→ ステータスページ更新

3. 原因調査（30分以内）
   └→ ログ分析
   └→ メトリクス確認
   └→ エラートレース

4. 復旧作業
   └→ 緊急パッチ or ロールバック
   └→ サービス再起動
   └→ 動作確認

5. 事後対応（24時間以内）
   └→ インシデントレポート作成
   └→ 再発防止策策定
   └→ ポストモーテム会議
```

---

### 緊急ロールバック手順

```bash
#!/bin/bash
# rollback/emergency-rollback.sh

set -e

CLUSTER="affiliate-system-cluster"
SERVICE="affiliate-web"

echo "🚨 EMERGENCY ROLLBACK INITIATED 🚨"

# 1. 現在のタスク定義取得
CURRENT_TASK_DEF=$(aws ecs describe-services \
  --cluster ${CLUSTER} \
  --services ${SERVICE} \
  --query 'services[0].taskDefinition' \
  --output text)

echo "Current task definition: ${CURRENT_TASK_DEF}"

# 2. タスク定義履歴から1つ前のバージョン取得
PREVIOUS_TASK_DEF=$(aws ecs list-task-definitions \
  --family-prefix affiliate-web \
  --sort DESC \
  --max-items 2 \
  --query 'taskDefinitionArns[1]' \
  --output text)

echo "Rolling back to: ${PREVIOUS_TASK_DEF}"

# 3. ロールバック実行
aws ecs update-service \
  --cluster ${CLUSTER} \
  --service ${SERVICE} \
  --task-definition ${PREVIOUS_TASK_DEF} \
  --force-new-deployment

# 4. ロールバック完了待機
echo "Waiting for rollback to complete..."

aws ecs wait services-stable \
  --cluster ${CLUSTER} \
  --services ${SERVICE}

# 5. ヘルスチェック
HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" https://api.affiliate-system.com/health)

if [ "$HTTP_CODE" -eq 200 ]; then
  echo "✅ Rollback completed successfully!"
else
  echo "❌ Rollback failed! HTTP Code: ${HTTP_CODE}"
  exit 1
fi

# 6. 通知
curl -X POST ${SLACK_WEBHOOK} -H 'Content-Type: application/json' -d \
  '{"text":"🚨 Emergency rollback completed. Previous version restored."}'
```

---

この運用ガイドにより、安定したシステム運用とインシデント対応が可能になります。
