# パフォーマンスチューニングガイド

## 📋 目次
1. [パフォーマンス目標](#パフォーマンス目標)
2. [データベース最適化](#データベース最適化)
3. [キャッシュ戦略](#キャッシュ戦略)
4. [非同期処理](#非同期処理)
5. [フロントエンド最適化](#フロントエンド最適化)
6. [負荷テスト](#負荷テスト)

---

## 🎯 パフォーマンス目標

### レスポンスタイム目標

| エンドポイント | P50 | P95 | P99 | 最大 |
|---------------|-----|-----|-----|------|
| GET /campaigns | 50ms | 150ms | 300ms | 1s |
| POST /tracking/click | 30ms | 100ms | 200ms | 500ms |
| POST /tracking/conversion | 80ms | 200ms | 400ms | 1s |
| GET /dashboard | 200ms | 500ms | 1s | 2s |
| GET /reports/* | 500ms | 2s | 5s | 10s |

### スループット目標

```
同時接続数: 10,000+
秒間リクエスト: 1,000+ RPS
日次トラフィック: 1億PV
月間コンバージョン: 1,000万件
```

---

## 🗄 データベース最適化

### 1. インデックス最適化

```sql
-- ❌ 悪い例: フルテーブルスキャン
SELECT * FROM clicks
WHERE campaign_id = 1001
  AND clicked_at >= '2024-01-01'
ORDER BY clicked_at DESC
LIMIT 100;

-- EXPLAIN結果
-- type: ALL (フルスキャン)
-- rows: 10,000,000
-- Extra: Using where; Using filesort

-- ✅ 良い例: 複合インデックス使用
CREATE INDEX idx_clicks_campaign_date ON clicks (
    campaign_id,
    clicked_at DESC
);

-- EXPLAIN結果
-- type: range
-- rows: 1,234
-- Extra: Using index condition
```

### インデックス設計パターン

```sql
-- パターン1: カーディナリティ順
CREATE INDEX idx_conversions_optimal ON conversions (
    status,           -- 高カーディナリティ（4種類）
    affiliate_id,     -- 中カーディナリティ（数万）
    converted_at      -- 高カーディナリティ（ユニーク）
);

-- パターン2: カバリングインデックス
CREATE INDEX idx_conversion_summary ON conversions (
    affiliate_id,
    status,
    converted_at
) INCLUDE (
    commission_amount,
    order_amount
);

-- パターン3: 部分インデックス（PostgreSQL）
CREATE INDEX idx_active_campaigns ON campaigns (id)
WHERE status = 'active';

-- パターン4: 関数ベースインデックス
CREATE INDEX idx_email_lower ON users (LOWER(email));
```

---

### 2. クエリ最適化

#### N+1問題の解消

```php
// ❌ 悪い例: N+1クエリ（101回のクエリ）
$conversions = Conversion::limit(100)->get();

foreach ($conversions as $conversion) {
    echo $conversion->campaign->name;  // 各行で1クエリ
}

// ✅ 良い例: Eager Loading（2回のクエリ）
$conversions = Conversion::with('campaign')->limit(100)->get();

foreach ($conversions as $conversion) {
    echo $conversion->campaign->name;
}

// ✅ さらに良い例: 選択的 Eager Loading
$conversions = Conversion::with('campaign:id,name')
    ->select('id', 'campaign_id', 'commission_amount')
    ->limit(100)
    ->get();
```

#### サブクエリ最適化

```sql
-- ❌ 遅い: 相関サブクエリ
SELECT a.id, a.name,
    (SELECT COUNT(*) FROM conversions WHERE affiliate_id = a.id) as conversion_count
FROM affiliates a;

-- ✅ 速い: JOIN
SELECT a.id, a.name, COUNT(c.id) as conversion_count
FROM affiliates a
LEFT JOIN conversions c ON c.affiliate_id = a.id
GROUP BY a.id, a.name;

-- ✅ さらに速い: 集計テーブル使用
SELECT a.id, a.name, s.conversion_count
FROM affiliates a
LEFT JOIN affiliate_statistics s ON s.affiliate_id = a.id;
```

---

### 3. パーティショニング

```sql
-- 月次パーティション（clicks テーブル）
CREATE TABLE clicks (
    id BIGINT AUTO_INCREMENT,
    campaign_id BIGINT NOT NULL,
    clicked_at TIMESTAMP NOT NULL,
    ...
    PRIMARY KEY (id, clicked_at)
) PARTITION BY RANGE (UNIX_TIMESTAMP(clicked_at)) (
    PARTITION p202401 VALUES LESS THAN (UNIX_TIMESTAMP('2024-02-01')),
    PARTITION p202402 VALUES LESS THAN (UNIX_TIMESTAMP('2024-03-01')),
    ...
);

-- パーティションプルーニング効果
-- ✅ 1ヶ月分のみスキャン
SELECT * FROM clicks
WHERE clicked_at >= '2024-01-01' AND clicked_at < '2024-02-01';

-- 古いパーティション削除（高速）
ALTER TABLE clicks DROP PARTITION p202301;
```

---

### 4. 集計テーブル（マテリアライズドビュー）

```sql
-- 日次集計テーブル
CREATE TABLE daily_campaign_stats (
    date DATE NOT NULL,
    campaign_id BIGINT NOT NULL,
    clicks INT DEFAULT 0,
    conversions INT DEFAULT 0,
    revenue DECIMAL(15,2) DEFAULT 0,
    commission DECIMAL(15,2) DEFAULT 0,
    cvr DECIMAL(5,2) DEFAULT 0,
    PRIMARY KEY (date, campaign_id),
    INDEX idx_campaign (campaign_id, date),
    INDEX idx_date (date)
) ENGINE=InnoDB;

-- 日次バッチで更新
INSERT INTO daily_campaign_stats
SELECT
    DATE(clicked_at) as date,
    campaign_id,
    COUNT(*) as clicks,
    SUM(CASE WHEN conversion_id IS NOT NULL THEN 1 ELSE 0 END) as conversions,
    SUM(COALESCE(order_amount, 0)) as revenue,
    SUM(COALESCE(commission_amount, 0)) as commission,
    ROUND(SUM(CASE WHEN conversion_id IS NOT NULL THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as cvr
FROM clicks c
LEFT JOIN conversions conv ON conv.click_id = c.id
WHERE DATE(clicked_at) = CURDATE() - INTERVAL 1 DAY
GROUP BY DATE(clicked_at), campaign_id
ON DUPLICATE KEY UPDATE
    clicks = VALUES(clicks),
    conversions = VALUES(conversions),
    revenue = VALUES(revenue),
    commission = VALUES(commission),
    cvr = VALUES(cvr);
```

---

## 🚀 キャッシュ戦略

### 1. Redis キャッシュ実装

```php
<?php
// app/Services/Cache/CampaignCache.php

class CampaignCache
{
    private $redis;
    private $ttl = 3600; // 1時間

    /**
     * アクティブキャンペーン一覧（キャッシュ）
     */
    public function getActiveCampaigns(): array
    {
        $cacheKey = 'campaigns:active';

        // キャッシュから取得
        $cached = $this->redis->get($cacheKey);

        if ($cached !== false) {
            return json_decode($cached, true);
        }

        // DB から取得
        $campaigns = Campaign::where('status', 'active')
            ->where('starts_at', '<=', now())
            ->where(function($q) {
                $q->whereNull('ends_at')
                  ->orWhere('ends_at', '>=', now());
            })
            ->select('id', 'name', 'commission_type', 'commission_value')
            ->get()
            ->toArray();

        // キャッシュに保存
        $this->redis->setex($cacheKey, $this->ttl, json_encode($campaigns));

        return $campaigns;
    }

    /**
     * キャンペーン詳細（キャッシュ）
     */
    public function getCampaign(int $id): ?array
    {
        $cacheKey = "campaign:{$id}";

        return Cache::remember($cacheKey, $this->ttl, function() use ($id) {
            return Campaign::with(['category', 'creatives'])
                ->find($id)
                ?->toArray();
        });
    }

    /**
     * キャッシュ無効化
     */
    public function invalidate(int $campaignId): void
    {
        Cache::forget("campaign:{$campaignId}");
        Cache::forget('campaigns:active');
        Cache::tags(['campaigns'])->flush();
    }
}
```

---

### 2. クエリ結果キャッシュ（多層キャッシュ）

```php
<?php
// 多層キャッシュ戦略

class MultiLayerCache
{
    /**
     * L1: アプリケーションメモリキャッシュ（APCu）
     * L2: Redis（分散キャッシュ）
     * L3: データベース
     */
    public function get(string $key, Closure $callback, int $ttl = 3600)
    {
        // L1: APCu チェック
        if (extension_loaded('apcu')) {
            $l1Value = apcu_fetch($key, $success);
            if ($success) {
                return $l1Value;
            }
        }

        // L2: Redis チェック
        $l2Value = Redis::get($key);
        if ($l2Value !== null) {
            // L1に書き戻し
            if (extension_loaded('apcu')) {
                apcu_store($key, $l2Value, min($ttl, 300)); // 最大5分
            }
            return $l2Value;
        }

        // L3: データベース
        $value = $callback();

        // キャッシュに保存
        Redis::setex($key, $ttl, $value);

        if (extension_loaded('apcu')) {
            apcu_store($key, $value, min($ttl, 300));
        }

        return $value;
    }
}
```

---

### 3. CDN / 静的コンテンツキャッシュ

```nginx
# nginx.conf

# 静的ファイルキャッシュ
location ~* \.(jpg|jpeg|png|gif|ico|css|js|svg|woff2)$ {
    expires 1y;
    add_header Cache-Control "public, immutable";
    add_header X-Content-Type-Options "nosniff";
}

# API レスポンスキャッシュ（nginx proxy cache）
proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=api_cache:10m max_size=1g inactive=60m;

location /api/v1/campaigns {
    proxy_cache api_cache;
    proxy_cache_valid 200 5m;
    proxy_cache_key "$scheme$request_method$host$request_uri";
    proxy_cache_bypass $http_cache_control;
    add_header X-Cache-Status $upstream_cache_status;

    proxy_pass http://backend;
}
```

---

## ⚡ 非同期処理

### 1. キュー実装（Laravel Queue）

```php
<?php
// app/Jobs/ProcessConversionJob.php

class ProcessConversionJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public $tries = 3;
    public $timeout = 120;
    public $backoff = [10, 30, 60]; // リトライ間隔（秒）

    private $conversionData;

    public function __construct(array $conversionData)
    {
        $this->conversionData = $conversionData;
    }

    public function handle()
    {
        DB::transaction(function() {
            // 1. コンバージョン登録
            $conversion = Conversion::create($this->conversionData);

            // 2. 不正検知
            $fraudCheck = app(FraudDetectionService::class)
                ->detectConversionFraud($conversion);

            $conversion->update([
                'fraud_score' => $fraudCheck['risk_score'],
                'is_suspicious' => $fraudCheck['action'] !== 'APPROVE'
            ]);

            // 3. 報酬計算
            if ($fraudCheck['action'] === 'APPROVE') {
                app(CommissionService::class)->calculateCommission($conversion);
            }

            // 4. 統計更新
            app(StatisticsService::class)->updateCampaignStats($conversion);

            // 5. Webhook 通知（非同期）
            dispatch(new SendWebhookJob('conversion.created', $conversion));

            // 6. メール通知（非同期）
            if ($conversion->status === 'approved') {
                dispatch(new SendConversionNotificationJob($conversion));
            }
        });
    }

    public function failed(Throwable $exception)
    {
        Log::error('Conversion processing failed', [
            'conversion_data' => $this->conversionData,
            'error' => $exception->getMessage()
        ]);

        // 失敗通知
        Notification::route('slack', config('slack.webhook_url'))
            ->notify(new JobFailedNotification($exception));
    }
}

// ジョブディスパッチ
dispatch(new ProcessConversionJob($conversionData))
    ->onQueue('conversions')  // 専用キュー
    ->delay(now()->addSeconds(5));  // 5秒遅延
```

---

### 2. バッチ処理最適化

```php
<?php
// app/Console/Commands/ProcessDailyStatistics.php

class ProcessDailyStatistics extends Command
{
    protected $signature = 'stats:daily {date?}';

    public function handle()
    {
        $date = $this->argument('date') ?: Carbon::yesterday()->toDateString();

        // チャンク処理（メモリ効率化）
        DB::table('clicks')
            ->whereDate('clicked_at', $date)
            ->orderBy('id')
            ->chunk(1000, function($clicks) use ($date) {
                $this->processChunk($clicks, $date);
            });

        $this->info('Daily statistics processed successfully');
    }

    private function processChunk($clicks, $date)
    {
        $stats = [];

        foreach ($clicks as $click) {
            $key = $click->campaign_id;

            if (!isset($stats[$key])) {
                $stats[$key] = [
                    'date' => $date,
                    'campaign_id' => $click->campaign_id,
                    'clicks' => 0,
                    'unique_clicks' => [],
                ];
            }

            $stats[$key]['clicks']++;
            $stats[$key]['unique_clicks'][$click->ip_address] = true;
        }

        // バルクインサート
        foreach ($stats as $stat) {
            DailyCampaignStat::updateOrCreate(
                [
                    'date' => $stat['date'],
                    'campaign_id' => $stat['campaign_id']
                ],
                [
                    'clicks' => DB::raw('clicks + ' . $stat['clicks']),
                    'unique_clicks' => count($stat['unique_clicks'])
                ]
            );
        }
    }
}
```

---

## 🌐 フロントエンド最適化

### 1. 遅延読み込み（Lazy Loading）

```javascript
// Vue.js コンポーネント遅延読み込み
const routes = [
    {
        path: '/dashboard',
        component: () => import(/* webpackChunkName: "dashboard" */ './views/Dashboard.vue')
    },
    {
        path: '/campaigns',
        component: () => import(/* webpackChunkName: "campaigns" */ './views/Campaigns.vue')
    }
];

// 画像遅延読み込み
<img
    data-src="/images/banner.jpg"
    class="lazy"
    loading="lazy"
    alt="Banner"
/>

// Intersection Observer API
const lazyImages = document.querySelectorAll('img.lazy');

const imageObserver = new IntersectionObserver((entries, observer) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            const img = entry.target;
            img.src = img.dataset.src;
            img.classList.remove('lazy');
            observer.unobserve(img);
        }
    });
});

lazyImages.forEach(img => imageObserver.observe(img));
```

---

### 2. バンドル最適化

```javascript
// vite.config.js
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';

export default defineConfig({
    plugins: [vue()],
    build: {
        rollupOptions: {
            output: {
                manualChunks: {
                    // ベンダーコード分割
                    'vendor': ['vue', 'vue-router', 'axios'],
                    'charts': ['chart.js'],
                    'ui': ['element-plus']
                }
            }
        },
        // 圧縮
        minify: 'terser',
        terserOptions: {
            compress: {
                drop_console: true,  // console.log削除
                drop_debugger: true
            }
        }
    }
});
```

---

### 3. Service Worker（PWA）

```javascript
// service-worker.js

const CACHE_NAME = 'affiliate-system-v1';
const urlsToCache = [
    '/',
    '/css/app.css',
    '/js/app.js',
    '/images/logo.png'
];

// インストール
self.addEventListener('install', event => {
    event.waitUntil(
        caches.open(CACHE_NAME)
            .then(cache => cache.addAll(urlsToCache))
    );
});

// フェッチ（キャッシュファースト）
self.addEventListener('fetch', event => {
    event.respondWith(
        caches.match(event.request)
            .then(response => {
                // キャッシュヒット
                if (response) {
                    return response;
                }

                // ネットワークから取得
                return fetch(event.request).then(response => {
                    // 200レスポンスのみキャッシュ
                    if (!response || response.status !== 200) {
                        return response;
                    }

                    const responseToCache = response.clone();

                    caches.open(CACHE_NAME).then(cache => {
                        cache.put(event.request, responseToCache);
                    });

                    return response;
                });
            })
    );
});
```

---

## 🧪 負荷テスト

### 1. Apache JMeter シナリオ

```xml
<!-- jmeter-test-plan.jmx -->
<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2">
    <hashTree>
        <TestPlan>
            <ThreadGroup>
                <!-- 1000並行ユーザー -->
                <stringProp name="ThreadGroup.num_threads">1000</stringProp>
                <!-- 300秒かけてランプアップ -->
                <stringProp name="ThreadGroup.ramp_time">300</stringProp>
                <!-- 各ユーザー10回ループ -->
                <stringProp name="ThreadGroup.loops">10</stringProp>
            </ThreadGroup>

            <!-- HTTPリクエスト: キャンペーン一覧 -->
            <HTTPSampler>
                <stringProp name="HTTPSampler.domain">api.affiliate-system.com</stringProp>
                <stringProp name="HTTPSampler.path">/api/v1/campaigns</stringProp>
                <stringProp name="HTTPSampler.method">GET</stringProp>
            </HTTPSampler>

            <!-- HTTPリクエスト: クリック記録 -->
            <HTTPSampler>
                <stringProp name="HTTPSampler.path">/api/v1/tracking/click</stringProp>
                <stringProp name="HTTPSampler.method">POST</stringProp>
            </HTTPSampler>
        </TestPlan>
    </hashTree>
</jmeterTestPlan>
```

---

### 2. Locust 負荷テスト（Python）

```python
# locustfile.py

from locust import HttpUser, task, between
import random

class AffiliateSystemUser(HttpUser):
    wait_time = between(1, 3)  # 1-3秒待機

    def on_start(self):
        """ログイン"""
        self.client.post("/api/v1/auth/login", json={
            "email": "test@example.com",
            "password": "password123"
        })

    @task(3)  # 重み付け（3倍頻繁に実行）
    def view_campaigns(self):
        """キャンペーン一覧閲覧"""
        self.client.get("/api/v1/campaigns")

    @task(2)
    def view_dashboard(self):
        """ダッシュボード閲覧"""
        self.client.get("/api/v1/account/me")

    @task(1)
    def record_click(self):
        """クリック記録"""
        campaign_id = random.randint(1, 100)
        self.client.post("/api/v1/tracking/click", json={
            "campaign_id": campaign_id,
            "affiliate_id": 12345
        })

# 実行コマンド
# locust -f locustfile.py --users 1000 --spawn-rate 50 --host https://api.affiliate-system.com
```

---

### 3. k6 負荷テスト（JavaScript）

```javascript
// k6-load-test.js

import http from 'k6/http';
import { check, sleep } from 'k6';

export let options = {
    stages: [
        { duration: '2m', target: 100 },   // 2分で100ユーザーまで
        { duration: '5m', target: 100 },   // 5分間100ユーザー維持
        { duration: '2m', target: 500 },   // 2分で500ユーザーまで
        { duration: '5m', target: 500 },   // 5分間500ユーザー維持
        { duration: '2m', target: 1000 },  // 2分で1000ユーザーまで
        { duration: '5m', target: 1000 },  // 5分間1000ユーザー維持
        { duration: '5m', target: 0 },     // ランプダウン
    ],
    thresholds: {
        http_req_duration: ['p(95)<500', 'p(99)<1000'],  // 95%が500ms以内
        http_req_failed: ['rate<0.01'],  // エラー率1%未満
    },
};

export default function() {
    // キャンペーン一覧取得
    let campaignsRes = http.get('https://api.affiliate-system.com/api/v1/campaigns');

    check(campaignsRes, {
        'status is 200': (r) => r.status === 200,
        'response time < 500ms': (r) => r.timings.duration < 500,
    });

    sleep(1);

    // クリック記録
    let clickPayload = JSON.stringify({
        campaign_id: Math.floor(Math.random() * 100) + 1,
        affiliate_id: 12345
    });

    let clickRes = http.post(
        'https://api.affiliate-system.com/api/v1/tracking/click',
        clickPayload,
        { headers: { 'Content-Type': 'application/json' } }
    );

    check(clickRes, {
        'click recorded': (r) => r.status === 201,
    });

    sleep(2);
}
```

---

## 📊 モニタリング・プロファイリング

### 1. New Relic APM 統合

```php
<?php
// app/Http/Middleware/NewRelicTransaction.php

class NewRelicTransaction
{
    public function handle($request, Closure $next)
    {
        if (extension_loaded('newrelic')) {
            // トランザクション名設定
            newrelic_name_transaction($request->route()->getName());

            // カスタムパラメータ追加
            newrelic_add_custom_parameter('user_id', auth()->id());
            newrelic_add_custom_parameter('user_type', auth()->user()?->user_type);
        }

        $response = $next($request);

        return $response;
    }
}
```

---

### 2. スロークエリ分析

```sql
-- スロークエリログ有効化
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1;  -- 1秒以上
SET GLOBAL log_queries_not_using_indexes = 'ON';

-- スロークエリ分析（pt-query-digest）
pt-query-digest /var/log/mysql/mysql-slow.log

-- 出力例
# Query 1: 12.5 QPS, 0.95x concurrency
# Time range: 2024-01-15 10:00:00 to 11:00:00
# Attribute    pct   total     min     max     avg     95%  stddev  median
# ============ === ======= ======= ======= ======= ======= ======= =======
# Count         45   45000
# Exec time     67   3420s     1ms     15s    76ms   150ms   234ms    45ms
# Lock time      0    12s     0us   100ms   267us   500us     2ms   100us
# Rows sent     40  500000       0   10000      11      20      15      10

SELECT * FROM conversions
WHERE affiliate_id = ?
  AND status = 'approved'
ORDER BY converted_at DESC
LIMIT 100;
```

---

これらの最適化により、大規模トラフィックに耐えうる高性能なASPシステムを実現できます。
